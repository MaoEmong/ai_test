# TASK01: single_table_product_agent.py 단기 최적화 메모

이 문서는 “몇 번 쓰고 끝”나는 단기 사용을 전제로 한 빠른 최적화 항목만 정리한다.
보안 강화/환경변수화는 범위에서 제외한다.

## 빠른 효과 (낮은 작업량, 즉시 체감)
- **중복 컴파일 제거**: `/plan`과 `/execute`에서 둘 다 `build_sql`을 호출한다. `/plan`에서 만든 SQL을 응답에 포함하고 `/execute`에서 재사용하면 CPU/로직 중복을 줄일 수 있다.
- **프리뷰 쿼리 최소화**: DELETE는 어차피 confirm이 필요하므로 프리뷰를 생략하고 경고만 반환한다.
- **불필요 업데이트 방지**: `set_values`가 비었거나 변경 의미가 없는 경우 즉시 에러/경고로 종료한다.

## DB 성능 개선
- **인덱스 추가**: `product(id)`는 PK 유지, 필터링이 잦은 `price`, `qty`에 인덱스를 추가하면 조회 속도가 빨라진다.
- **행 수 제한 축소**: 기본 limit 50을 20 정도로 낮추면 응답 속도가 빨라진다.
- **연결 재사용**: `pymysql`은 기본 풀링이 없다. 짧게라도 풀을 쓰면 반복 호출에서 체감된다(간단한 풀 래퍼나 경량 풀 라이브러리).

## LLM 호출 최적화
- **프롬프트 축소**: `TABLE_PROMPT`에서 불필요 설명을 줄이면 토큰과 지연이 감소한다.
- **스키마 고정**: `Plan.model_json_schema()` 대신 고정 JSON 스키마를 직접 정의하면 응답이 더 작고 안정적이다.
- **응답 크기 최소화**: “JSON만 출력” 요구를 유지하고, 모델이 여분 텍스트를 붙이지 않게 프롬프트를 더 간결하게 한다.

## SQL 빌더 개선
- **IN 리스트 배치 처리**: `IN` 값이 길어지면 쿼리가 커진다. 일정 길이로 나눠 여러 번 실행하거나 임시 테이블로 대체한다.
- **WHERE 정규화**: 단일 `id` 조건도 `IN` 경로로 처리해 로직 분기를 줄일 수 있다.

## 단기 안정성 향상
- **모델 실패 시 대체**: 설정된 모델이 실패할 경우, 사용 가능한 모델로 한 번 fallback하도록 한다.
- **파싱 재시도**: LLM JSON 파싱 실패 시, 프롬프트를 줄여 1회 재시도하면 실패율이 낮아진다.
- **DB 타임아웃**: `connect_timeout`, `read_timeout`을 추가해 멈춤을 방지한다.

## 적용 순서 제안
1. SQL 캐싱으로 중복 빌드 제거
2. 프리뷰 쿼리 최소화
3. 프롬프트/스키마 축소
4. 인덱스 추가

## 메모
- 단기 사용을 전제로 속도와 비용만 우선한다.
- 큰 구조 변경 없이 빠르게 적용 가능한 항목만 포함했다.
